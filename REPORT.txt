
- Explain how the arguments make it all the way from user program invoking
  execv until they turn into main's argc, and argv for the target program

The arguments are first tokenized and placed as arguments in a system call. The system call then moves the arguments into a SimpleQueue and passed to execv. In execv the location of the arguments is placed on the user stack in the location relative to the stack pointer so that they are read as arguments in the user space (The actual arguments are also stored in user memory).

Then in the user program, the pointer to the arguments is conveniently located above the stack pointer. 

- My implementation of execv in syscall.cc is not secure. Show a user
  program that can read any memory address by exploiting my bad code

A user program could pass in a pointer to memory as the arguments, and execv would blindly read from memory and pass it back to the user as arguments. By making a sneaky execv syscall, you could read any memory address.

- How would change the code to protect against this attack

We can add a check in the system call handler to make sure that the memory is from the user space and deny the system call if the user attempts to execv with kernal memory.

- What do we need to change in order to implement input and output
  redirection and pipes in the shell?

First we would need a dup system call that allowed the modification of the file descriptors. By opening (or in the case of output, creating) a file and then assigning it the correct File Descriptor number (0 for in, 1 for out) the shell will automatically write its output to the new file. 

For pipes, we also need to implement some kind of bounded buffer so that the second command can wait on the pipe until after the first command writes to it, then uses the contents of the pipe as input. 

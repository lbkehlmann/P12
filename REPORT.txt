Report.txt

Our project introduced the notion of users and permissions to our file system. 

First within fat439 we created 2 files; users.txt and filePerm.txt. User.txt holds entries for each username. These entries are the username (max of 8 characters) followed by a space and the users permission level. The permissions start with 0 as the level with the most permissions. Permissions decrease as level increases. Each user entry is separated by a new line. The second file, filePerm.txt has file entries separated by new lines as well. Each entry begins with an l which represents level or a u which represents user. If the first character is an m it is followed by a space and the maximum level of a user allowed to access it, then another space, and then the file name. If the first character is a u it is followed by a space and the username of the files owner, then another space, and then the file name. A file owned by a particular individual cannot be accessed by any other user. A file which is protected only by a permission level can be accessed by anyone at the same permission level or lower.

The first step we took was to redirect init.cc to execv our own program, chuser (change user). This initialized a modified version of the shell which asks the user to enter a valid username. No other files can be accessed until a valid username is entered. Once a username is entered, the user may log out at any time by typing the command chuser and log back in by typing another username. Once a user has put in a valid username, we execv into shell. We added a third optional argument to execv: the username. This username includes the users level of permissions. This allowed us to more easily access the users permission for level checks in user code.

Next we modified all commands accessing any files in fat439, most notably ls and cat. Ls checks the users permissions against the files permissions and only prints those the user has access to view. Cat ensures that the user trying to access a certain file has permission to do so, and then prints the file if it exists.

